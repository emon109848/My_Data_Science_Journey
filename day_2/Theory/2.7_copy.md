Perfect ğŸ”¥
Hereâ€™s your **PRINTABLE â€œCopying Objectsâ€ CHEAT SHEET** â€” compact, structured, interview-ready.

---

# ğŸ“Œ PYTHON COPYING OBJECTS â€” COMPLETE REVISION SHEET

---

# ğŸ§  Why Copying Matters

* Assignment (`=`) **does not create a new object**
* Changes to one variable may affect the other if mutable
* Copying ensures **separate objects**

---

# ğŸ”¹ 1ï¸âƒ£ Assignment vs Copy

```python
a = [1, 2, 3]
b = a          # assignment â†’ same object
b.append(4)
print(a)       # [1, 2, 3, 4] â†’ both changed
```

---

# ğŸ”¹ 2ï¸âƒ£ Shallow Copy

* Creates a **new outer object**, but inner objects **refer to same memory**
* Use `copy.copy()`

```python
import copy

a = [[1,2],[3,4]]
b = copy.copy(a)  # shallow copy
b[0].append(5)
print(a)  # [[1,2,5],[3,4]] â†’ inner list changed
```

---

# ğŸ”¹ 3ï¸âƒ£ Deep Copy

* Creates **completely independent object**
* Use `copy.deepcopy()`

```python
import copy

a = [[1,2],[3,4]]
b = copy.deepcopy(a)
b[0].append(5)
print(a)  # [[1,2],[3,4]] â†’ original unchanged
```

---

# ğŸ”¹ 4ï¸âƒ£ Mutable vs Immutable Types

| Type                              | Copy Behavior                       |
| --------------------------------- | ----------------------------------- |
| Immutable (int, str, tuple)       | No need to copy; cannot change      |
| Mutable (list, dict, set, object) | Copy required to avoid side-effects |

---

# ğŸ”¹ 5ï¸âƒ£ Memory Reference Concept

```python
a = [1,2,3]
b = a
id(a), id(b)  # same â†’ assignment shares reference

c = copy.copy(a)
id(a), id(c)  # different â†’ shallow copy

d = copy.deepcopy(a)
id(a), id(d)  # different â†’ deep copy
```

* `id()` shows memory address
* Shallow copy â†’ only outer object new
* Deep copy â†’ all nested objects new

---

# ğŸ”¹ 6ï¸âƒ£ When to Use

âœ… Shallow copy â†’ flat lists, shallow structures
âœ… Deep copy â†’ nested lists, dictionaries, objects
âœ… Avoid unintended mutation of mutable objects

---

# ğŸ¯ Common Mistakes

âŒ Using `=` thinking it copies
âŒ Using shallow copy for nested structures
âŒ Not importing `copy` module
âŒ Ignoring mutable vs immutable types

---

# ğŸ”¥ Interview Questions (Copying)

1. Difference between assignment, shallow copy, and deep copy?
2. How do you perform shallow and deep copies in Python?
3. What happens if you modify a shallow copy?
4. Which types are immutable?
5. How does memory reference affect copying behavior?
6. Can deepcopy be used on immutable types?
7. Explain a real-world scenario where deep copy is required.
8. Show difference between `copy.copy()` and `copy.deepcopy()` with nested lists.

---

If you want, I can **next create a single printable â€œAdvanced Python Theory Cheat Sheet â€” Functional, Iteration, Args, Copyingâ€** that includes **lambda, map, filter, reduce, zip, enumerate, *args, **kwargs, and copying objects** with examples + interview questions â€” perfect for Day 2 revision.

Do you want me to prepare that?
