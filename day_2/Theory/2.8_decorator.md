
---

# üìå PYTHON DECORATORS ‚Äî COMPLETE REVISION SHEET

---

# üß† What is a Decorator?

* A **decorator** is a **function that takes another function as input** and returns a **modified or enhanced function**.
* Uses **first-class functions** and **closures**.
* Often used for **logging, timing, authentication**.

---

# üîπ 1Ô∏è‚É£ First-Class Functions

* Functions can be:

  * Assigned to variables
  * Passed as arguments
  * Returned from other functions

```python
def greet(name):
    return f"Hello {name}"

f = greet
print(f("Emon"))  # Hello Emon
```

---

# üîπ 2Ô∏è‚É£ Nested Functions & Wrapper

```python
def decorator(func):
    def wrapper():
        print("Before function call")
        func()
        print("After function call")
    return wrapper

def say_hello():
    print("Hello!")

say_hello = decorator(say_hello)
say_hello()
```

Output:

```
Before function call
Hello!
After function call
```

---

# üîπ 3Ô∏è‚É£ Using `@decorator` Syntax

```python
@decorator
def say_hello():
    print("Hello!")

say_hello()
```

* Equivalent to `say_hello = decorator(say_hello)`
* Cleaner and Pythonic

---

# üîπ 4Ô∏è‚É£ Using `*args` and `**kwargs` in Decorators

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Before function call")
        result = func(*args, **kwargs)
        print("After function call")
        return result
    return wrapper

@decorator
def greet(name):
    print(f"Hello {name}")
    return "Done"

greet("Emon")
```

* Allows decorating functions with **any number of positional & keyword arguments**

---

# üîπ 5Ô∏è‚É£ Practical Use Cases

1. **Logging**

```python
def log(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper
```

2. **Timing**

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end-start:.4f} seconds")
        return result
    return wrapper
```

3. **Authentication / Permissions**

```python
def authenticate(func):
    def wrapper(user):
        if user != "admin":
            print("Access denied")
        else:
            func(user)
    return wrapper
```

---

# üîπ 6Ô∏è‚É£ Order of Multiple Decorators

```python
@decorator1
@decorator2
def func():
    pass
```

* Applied **bottom ‚Üí top**
* `func = decorator1(decorator2(func))`

---

# üß† INTERNAL WORKING

1. Decorator **takes a function object** as input
2. Defines a **wrapper function**
3. Wrapper **adds behavior** and calls original function
4. Returns the **wrapper function object**

---

# üéØ Common Mistakes

‚ùå Forgetting `*args, **kwargs` in wrapper ‚Üí breaks functions with parameters
‚ùå Not returning result from wrapper
‚ùå Using decorator incorrectly without `@`
‚ùå Overcomplicating nested decorators

---

# üî• Interview Questions (Decorators)

1. What is a decorator in Python?
2. Explain first-class functions.
3. How does `@decorator` syntax work?
4. Difference between normal wrapper vs decorator with `@`.
5. How to pass arguments to a decorated function?
6. What is the role of `*args` and `**kwargs` in decorators?
7. Show a practical use case for logging or timing.
8. Explain order of multiple decorators.
9. Can decorators be nested inside functions?
10. What is a closure and how is it related to decorators?

---

If you want, I can now **create a full Day 2 ‚ÄúAdvanced Python Theory & Functional Programming Cheat Sheet‚Äù** including:

* Lambda, map, filter, reduce
* zip, enumerate
* *args, **kwargs
* Copying objects
* Decorators

All in **one printable page with examples + interview questions**, perfect for revision and GitHub notes.

Do you want me to prepare that?
